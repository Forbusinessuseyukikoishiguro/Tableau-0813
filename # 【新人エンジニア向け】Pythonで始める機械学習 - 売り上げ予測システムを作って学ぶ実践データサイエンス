# 【新人エンジニア向け】Pythonで始める機械学習 - 売り上げ予測システムを作って学ぶ実践データサイエンス
https://colab.research.google.com/drive/1RFGMoNXwN_DoHqCjmNtV1XlS2htThYLz?authuser=0#scrollTo=2-bOIyBlghJj
## はじめに

機械学習って難しそう...と思っている新人エンジニアの皆さん、こんにちは！

この記事では、**実際に動く売り上げ予測システム**を作りながら、機械学習の基礎を学んでいきます。理論だけでなく、**コード一行一行の意味**を丁寧に解説していくので、プログラミング初心者でも安心してついてこれます。

### 🎯 この記事で学べること

- **Python基本ライブラリの使い方** (pandas, numpy, matplotlib)
- **機械学習の基本概念** (特徴量、訓練・テストデータ、評価指標)
- **ランダムフォレスト**というアルゴリズムの実装
- **データ可視化**の基本テクニック
- **予測モデル**の作り方と評価方法

### 📋 前提知識

- Python基本文法（変数、関数、if文、for文）
- 高校数学レベルの統計知識があると理想的（なくてもOK）

それでは、一緒にコードを書きながら学んでいきましょう！

---

## 1. 環境準備とライブラリインポート

まずは必要なライブラリをインポートしていきます。

```python
# 必要なライブラリをインポート
import pandas as pd  # データ操作用
import numpy as np   # 数値計算用
import matplotlib.pyplot as plt  # グラフ描画用
import seaborn as sns           # 統計グラフ用
from sklearn.ensemble import RandomForestRegressor  # 機械学習モデル
from sklearn.model_selection import train_test_split  # データ分割用
from sklearn.metrics import mean_absolute_error, r2_score  # 評価指標
from datetime import datetime, timedelta  # 日付操作用
import warnings  # 警告制御用
warnings.filterwarnings('ignore')  # 警告を非表示にする
```

### 🔍 各ライブラリの役割解説

| ライブラリ | 役割 | なぜ必要？ |
|------------|------|------------|
| **pandas** | データ操作・分析 | CSVファイルの読み込み、データフレーム操作に必須 |
| **numpy** | 数値計算 | 配列操作、数学的計算の高速処理 |
| **matplotlib** | グラフ描画 | 予測結果の可視化 |
| **seaborn** | 統計グラフ | matplotlibより美しいグラフが簡単に作れる |
| **sklearn** | 機械学習 | 予測モデルの作成・評価 |
| **datetime** | 日付処理 | 時系列データの扱い |

```python
# グラフの日本語フォント設定（Googleコラボ用）
plt.rcParams['font.family'] = 'DejaVu Sans'  # 基本フォント設定
sns.set_style("whitegrid")  # グラフスタイル設定
```

**💡 ポイント**: `plt.rcParams`はmatplotlibの設定を変更するためのコマンド。日本語表示の問題を避けるために設定しています。

---

## 2. データ生成 - 現実的なサンプルデータを作る

実際のプロジェクトではCSVファイルを読み込みますが、今回は学習用に**リアルなサンプルデータを生成**します。

```python
print("📊 キャバクラ売り上げ予測システム開始")
print("=" * 50)

# サンプルデータ生成（実際の運用では実データを使用）
np.random.seed(42)  # 再現性のための乱数シード設定
n_samples = 365  # 1年分のデータを生成
```

**🔍 `np.random.seed(42)`って何？**

乱数を使った処理では、実行するたびに結果が変わってしまいます。`seed`を設定することで、**常に同じ乱数列**を生成でき、結果の再現性が保てます。

### 日付データの作成

```python
# 基本的な日付データを作成
start_date = datetime(2023, 1, 1)  # 開始日を設定
dates = [start_date + timedelta(days=i) for i in range(n_samples)]  # 365日分の日付リスト

# 空のデータフレームを初期化
data = pd.DataFrame()
```

**💡 リスト内包表記の解説**

```python
# これと同じ意味
dates = []
for i in range(n_samples):
    dates.append(start_date + timedelta(days=i))
```

### 特徴量の作成

機械学習では、**特徴量（feature）**が予測精度を左右します。売り上げに影響しそうな要素を考えて作っていきます。

```python
# 日付関連の特徴量を作成
data['date'] = dates  # 日付カラム
data['year'] = [d.year for d in dates]  # 年
data['month'] = [d.month for d in dates]  # 月
data['day'] = [d.day for d in dates]  # 日
data['weekday'] = [d.weekday() for d in dates]  # 曜日（0=月曜、6=日曜）
data['is_weekend'] = data['weekday'] >= 5  # 週末フラグ（金土日）
```

**🔍 `weekday()`メソッド**

- 月曜日 = 0, 火曜日 = 1, ..., 日曜日 = 6
- `>= 5`で金土日を判定（金曜=5, 土曜=6, 日曜=0...あれ？）

実は日曜日は6じゃなくて0なので、正確には：

```python
# より正確な週末判定
data['is_weekend'] = (data['weekday'] >= 5) | (data['weekday'] == 6)
```

でも今回のコードでは金土を週末として扱っています。

### 季節性の考慮

```python
# 季節性を考慮した特徴量
data['season'] = data['month'].apply(lambda x: 
    0 if x in [12, 1, 2] else      # 冬
    1 if x in [3, 4, 5] else       # 春  
    2 if x in [6, 7, 8] else       # 夏
    3)                             # 秋
```

**🔍 `lambda`関数とは？**

```python
# lambda関数（無名関数）
lambda x: 0 if x in [12, 1, 2] else 1

# 通常の関数で書くと
def get_season(x):
    if x in [12, 1, 2]:
        return 0
    else:
        return 1
```

`lambda`は短い処理を1行で書ける便利な機能です。

### ビジネス要因の特徴量

```python
# 特別な日（給料日、ボーナス時期）のフラグ
data['is_payday'] = data['day'].apply(lambda x: 1 if x in [25, 26, 27] else 0)  # 給料日付近
data['is_bonus_month'] = data['month'].apply(lambda x: 1 if x in [6, 12] else 0)  # ボーナス月
```

**💡 なぜフラグ（0/1）にするの？**

機械学習アルゴリズムは数値しか扱えません。「給料日である/ない」という概念を、1/0の数値で表現しています。これを**ダミー変数**と呼びます。

### 外的要因の追加

```python
# 天気の影響（ランダムだが現実的な分布）
weather_types = ['晴れ', '曇り', '雨', '雪']  # 天気の種類
weather_weights = [0.5, 0.3, 0.15, 0.05]    # 各天気の出現確率
data['weather'] = np.random.choice(weather_types, n_samples, p=weather_weights)

# 天気を数値化（売り上げへの影響度）
weather_impact = {'晴れ': 1.0, '曇り': 0.9, '雨': 0.7, '雪': 0.5}
data['weather_score'] = data['weather'].map(weather_impact)
```

**🔍 `np.random.choice()`の使い方**

```python
np.random.choice(['A', 'B', 'C'], size=10, p=[0.5, 0.3, 0.2])
# A が50%、B が30%、C が20%の確率で選ばれる配列を10個生成
```

---

## 3. 目的変数（売り上げ）の計算

機械学習では、**予測したい値**を目的変数（target variable）と呼びます。ここでは複数の要因を組み合わせて、現実的な売り上げデータを生成します。

```python
# 目標売り上げを計算（現実的な要因を組み合わせ）
base_sales = 50000  # 基本売り上げ（円）

# 曜日効果（金土が高い）
weekday_multiplier = [0.7, 0.7, 0.8, 0.9, 1.3, 1.5, 1.2]  # 月～日の係数
data['weekday_effect'] = data['weekday'].apply(lambda x: weekday_multiplier[x])

# 月次効果（12月、3月が高い傾向）
monthly_multiplier = [0.9, 0.8, 1.2, 1.0, 0.9, 1.1, 1.0, 0.9, 0.9, 1.0, 1.0, 1.3]
data['monthly_effect'] = data['month'].apply(lambda x: monthly_multiplier[x-1])
```

**💡 なぜ`x-1`？**

月は1〜12の値ですが、リストのインデックスは0〜11なので、1を引いて調整しています。

### 複雑な売り上げ計算式

```python
# 売り上げ計算（複数要因の組み合わせ）
data['sales'] = (
    base_sales *                                    # 基本売り上げ
    data['weekday_effect'] *                        # 曜日効果
    data['monthly_effect'] *                        # 月次効果  
    data['weather_score'] *                         # 天気効果
    (1 + data['is_payday'] * 0.2) *                # 給料日効果（+20%）
    (1 + data['is_bonus_month'] * 0.3) *           # ボーナス月効果（+30%）
    (1 + data['has_event'] * 0.4) *                # イベント効果（+40%）
    (data['cast_count'] / base_cast) *             # キャスト数効果
    np.random.normal(1, 0.1, n_samples)            # ランダムノイズ（±10%）
)
```

**🔍 各項目の解説**

- `base_sales`: ベースとなる売り上げ
- `weekday_effect`: 曜日による影響（金土は1.3〜1.5倍）
- `(1 + data['is_payday'] * 0.2)`: 給料日なら1.2倍（20%増）
- `np.random.normal(1, 0.1, n_samples)`: 平均1、標準偏差0.1の正規分布ノイズ

**💡 なぜノイズを加える？**

現実のデータには必ず**ランダムな変動**があります。完璧に予測可能なデータより、少しブレのあるデータの方がリアルです。

---

## 4. データの確認と基本統計

```python
# データの概要を表示
print("🔍 生成されたデータの概要:")
print(f"データ期間: {data['date'].min().strftime('%Y-%m-%d')} ～ {data['date'].max().strftime('%Y-%m-%d')}")
print(f"総レコード数: {len(data):,} 件")
print(f"平均売り上げ: {data['sales'].mean():,.0f} 円")
print(f"売り上げ範囲: {data['sales'].min():,} ～ {data['sales'].max():,} 円")

# 基本統計情報を表示
print("📈 売り上げ統計:")
print(data['sales'].describe())
```

**🔍 `describe()`メソッド**

pandasの`describe()`は以下の統計値を一度に表示します：

- **count**: データ数
- **mean**: 平均値
- **std**: 標準偏差
- **min/max**: 最小値/最大値
- **25%/50%/75%**: 四分位数

これらは**データの分布を理解**するのに重要な指標です。

---

## 5. 機械学習モデルの準備

### 特徴量の選択

```python
# 機械学習用の特徴量を準備
feature_columns = [
    'month', 'weekday', 'season', 'is_weekend', 
    'is_payday', 'is_bonus_month', 'weather_score', 
    'has_event', 'cast_count'
]

# 特徴量（X）と目標変数（y）を分離
X = data[feature_columns]  # 説明変数
y = data['sales']          # 目的変数（売り上げ）
```

**🔍 なぜ特徴量を選ぶ？**

- **関係ない特徴量**は予測精度を下げる可能性がある
- **日付そのもの**は直接使わず、曜日や月などに変換して使う
- 機械学習は**数値データ**しか扱えない

### データの分割

```python
# データを訓練用とテスト用に分割（8:2の比率）
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, shuffle=True
)
```

**🔍 なぜデータを分割する？**

- **訓練データ**: モデルの学習に使用
- **テストデータ**: モデルの性能評価に使用
- 同じデータで学習と評価をすると、**過学習**を見抜けない

**💡 過学習とは？**

訓練データには完璧に適合するが、新しいデータでは全然当たらない状態。テストのために覚えた内容しか答えられない状況に似ています。

---

## 6. ランダムフォレストモデルの訓練

```python
# ランダムフォレスト回帰モデルを作成・訓練
print("🤖 機械学習モデル訓練中...")
model = RandomForestRegressor(
    n_estimators=100,    # 決定木の数
    random_state=42,     # 再現性のため
    max_depth=10,        # 木の最大深度
    min_samples_split=5, # 分割に必要な最小サンプル数
    n_jobs=-1           # 並列処理（全CPU使用）
)

# モデルを訓練データで学習
model.fit(X_train, y_train)
```

**🔍 ランダムフォレストとは？**

**複数の決定木**を組み合わせたアルゴリズム。それぞれの木が予測を出し、最終的に平均を取ります。

```
木1の予測: 52,000円
木2の予測: 48,000円
木3の予測: 50,000円
...
最終予測: (52,000 + 48,000 + 50,000 + ...) / 100 = 50,000円
```

**各パラメータの意味**

- `n_estimators=100`: 100本の決定木を使用
- `max_depth=10`: 各木の深さを最大10層に制限
- `min_samples_split=5`: ノード分割に最低5サンプル必要
- `n_jobs=-1`: 全CPU core を使って並列処理

---

## 7. モデルの評価

```python
# テストデータで予測を実行
y_pred = model.predict(X_test)

# モデルの性能を評価
mae = mean_absolute_error(y_test, y_pred)      # 平均絶対誤差
r2 = r2_score(y_test, y_pred)                  # 決定係数

print("📊 モデル性能評価:")
print(f"  平均絶対誤差 (MAE): {mae:,.0f} 円")
print(f"  決定係数 (R²): {r2:.3f}")
print(f"  平均誤差率: {mae/y_test.mean()*100:.1f}%")
```

**🔍 評価指標の解説**

### MAE（Mean Absolute Error）
```python
# 平均絶対誤差の計算方法
errors = abs(y_test - y_pred)  # 予測誤差の絶対値
mae = errors.mean()            # 平均を取る
```

**意味**: 平均的にどのくらい予測が外れるか（円単位で分かりやすい）

### R²（決定係数）
```python
# R²の意味（概念的に）
R² = 1 - (モデルの誤差) / (平均値で予測した場合の誤差)
```

- **R² = 1**: 完璧な予測
- **R² = 0**: 平均値で予測するのと同レベル
- **R² < 0**: 平均値で予測するより悪い

### 特徴量重要度の分析

```python
# 特徴量の重要度を計算・表示
feature_importance = pd.DataFrame({
    'feature': feature_columns,
    'importance': model.feature_importances_
}).sort_values('importance', ascending=False)

print("🔍 特徴量重要度ランキング:")
for i, (_, row) in enumerate(feature_importance.iterrows(), 1):
    print(f"  {i:2d}. {row['feature']:15s}: {row['importance']:.3f}")
```

**🔍 特徴量重要度とは？**

各特徴量が予測にどれだけ貢献しているかを0〜1の値で表したもの。合計は1になります。

**活用方法**
- 重要度の低い特徴量は削除を検討
- 重要な特徴量をさらに詳しく分析
- ビジネス的な意味を考えて施策を検討

---

## 8. データ可視化

```python
# 可視化用にグラフを作成
fig, axes = plt.subplots(2, 2, figsize=(15, 12))
fig.suptitle('キャバクラ売り上げ分析結果', fontsize=16, fontweight='bold')
```

**🔍 `plt.subplots(2, 2)`**

2×2のグリッド状に4つのグラフを配置します。`axes[0, 0]`で左上のグラフにアクセスできます。

### 1. 予測精度の可視化

```python
# 1. 実際vs予測の散布図
axes[0, 0].scatter(y_test, y_pred, alpha=0.6, color='blue')
axes[0, 0].plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)
axes[0, 0].set_xlabel('実際の売上 (円)')
axes[0, 0].set_ylabel('予測売上 (円)')
axes[0, 0].set_title(f'予測精度 (R² = {r2:.3f})')
axes[0, 0].grid(True, alpha=0.3)
```

**💡 なぜ散布図？**

理想的な予測では、点が赤い直線（y=x）上に並びます。ばらつきが少ないほど予測精度が高いです。

### 2. 曜日効果の分析

```python
# 2. 曜日別売り上げ傾向
weekday_names = ['月', '火', '水', '木', '金', '土', '日']
weekday_sales = data.groupby('weekday')['sales'].mean()
axes[0, 1].bar(range(7), weekday_sales.values, color='lightblue', edgecolor='navy')
```

**🔍 `groupby()`の動作**

```python
# groupby の動作イメージ
グループ0（月曜）: [45000, 47000, 44000, ...] → 平均: 45333円
グループ1（火曜）: [46000, 48000, 45000, ...] → 平均: 46333円
...
```

---

## 9. 将来予測の実装

```python
# 将来予測のサンプル（明日の売り上げ予測）
tomorrow = datetime.now() + timedelta(days=1)
tomorrow_features = {
    'month': tomorrow.month,
    'weekday': tomorrow.weekday(),
    'season': 0 if tomorrow.month in [12, 1, 2] else 1 if tomorrow.month in [3, 4, 5] else 2 if tomorrow.month in [6, 7, 8] else 3,
    'is_weekend': 1 if tomorrow.weekday() >= 5 else 0,
    'is_payday': 1 if tomorrow.day in [25, 26, 27] else 0,
    'is_bonus_month': 1 if tomorrow.month in [6, 12] else 0,
    'weather_score': 1.0,  # 晴れと仮定
    'has_event': 0,        # イベントなしと仮定
    'cast_count': 8        # 通常のキャスト数と仮定
}

# 予測用データフレームを作成
tomorrow_df = pd.DataFrame([tomorrow_features])

# 売り上げを予測
predicted_sales = model.predict(tomorrow_df)[0]
```

**🔍 新しいデータでの予測手順**

1. **同じ特徴量**を持つデータを作成
2. **DataFrame形式**に変換（scikit-learnの要求）
3. `predict()`メソッドで予測実行

### What-if分析

```python
# 条件を変えた場合の予測（What-if分析）
# 1. イベント開催時
event_condition = base_condition.copy()
event_condition['has_event'] = 1
event_sales = model.predict(pd.DataFrame([event_condition]))[0]
event_diff = event_sales - predicted_sales
```

**💡 What-if分析の価値**

- イベント開催の効果を事前に予測
- キャスト数増員の投資対効果を計算
- 天候の影響を定量化

---

## まとめ

### 🎉 学んだ技術スキル

#### Python基本技術
- **pandas**: データフレーム操作、groupby集計
- **numpy**: 配列操作、統計計算、乱数生成
- **matplotlib/seaborn**: データ可視化、複数グラフ配置

#### 機械学習の流れ
1. **データ準備**: 特徴量エンジニアリング
2. **データ分割**: train/test split
3. **モデル訓練**: fit()メソッド
4. **予測・評価**: predict()、評価指標の計算
5. **結果解釈**: 特徴量重要度、可視化

#### 実践的なポイント
- **再現性の確保**: random_stateの設定
- **現実的なデータ生成**: 複数要因の組み合わせ
- **適切な評価**: 複数指標での性能測定
- **ビジネス活用**: What-if分析、将来予測

### 🚀 次のステップ

#### 基礎固め
1. **pandas公式チュートリアル**でデータ操作を練習
2. **scikit-learn examples**で他のアルゴリズムを試す
3. **Kaggle Learn**で体系的な機械学習を学習

#### 応用発展
1. **時系列予測**（LSTM、Prophet）
2. **深層学習**（TensorFlow、PyTorch）
3. **MLOps**（モデルの本番運用）

#### 実践プロジェクト
1. **公開データセット**での予測コンペ参加
2. **自分の興味のある分野**でのデータ分析
3. **Webアプリ化**（Streamlit、Flask）

### 💡 重要な心構え

機械学習は**魔法ではありません**。データの質、適切な特徴量設計、ビジネス理解が成功の鍵です。

**まずは手を動かして、たくさん失敗して、そこから学ぶ**ことが一番の近道です。

今回のコードをベースに、ぜひ自分なりの改良を加えて実験してみてください！

---

### 📚 参考リンク

- [pandas公式ドキュメント](https://pandas.pydata.org/docs/)
- [scikit-learn User Guide](https://scikit-learn.org/stable/user_guide.html)
- [Kaggle Learn](https://www.kaggle.com/learn)
- [機械学習入門書籍](https://www.amazon.co.jp/dp/4873118896/)

**Happy Coding! 🎉**
