# キャバクラ売り上げ予測システム
# Googleコラボでそのまま実行可能

# 必要なライブラリをインポート
import pandas as pd  # データ操作用
import numpy as np   # 数値計算用
import matplotlib.pyplot as plt  # グラフ描画用
import seaborn as sns           # 統計グラフ用
from sklearn.ensemble import RandomForestRegressor  # 機械学習モデル
from sklearn.model_selection import train_test_split  # データ分割用
from sklearn.metrics import mean_absolute_error, r2_score  # 評価指標
from datetime import datetime, timedelta  # 日付操作用
import warnings  # 警告制御用
warnings.filterwarnings('ignore')  # 警告を非表示にする

# グラフの日本語フォント設定（Googleコラボ用）
plt.rcParams['font.family'] = 'DejaVu Sans'  # 基本フォント設定
sns.set_style("whitegrid")  # グラフスタイル設定

print("📊 キャバクラ売り上げ予測システム開始")
print("=" * 50)

# サンプルデータ生成（実際の運用では実データを使用）
np.random.seed(42)  # 再現性のための乱数シード設定
n_samples = 365  # 1年分のデータを生成

# 基本的な日付データを作成
start_date = datetime(2023, 1, 1)  # 開始日を設定
dates = [start_date + timedelta(days=i) for i in range(n_samples)]  # 365日分の日付リスト

# 空のデータフレームを初期化
data = pd.DataFrame()

# 日付関連の特徴量を作成
data['date'] = dates  # 日付カラム
data['year'] = [d.year for d in dates]  # 年
data['month'] = [d.month for d in dates]  # 月
data['day'] = [d.day for d in dates]  # 日
data['weekday'] = [d.weekday() for d in dates]  # 曜日（0=月曜、6=日曜）
data['is_weekend'] = data['weekday'] >= 5  # 週末フラグ（金土日）

# 季節性を考慮した特徴量
data['season'] = data['month'].apply(lambda x: 
    0 if x in [12, 1, 2] else      # 冬
    1 if x in [3, 4, 5] else       # 春  
    2 if x in [6, 7, 8] else       # 夏
    3)                             # 秋

# 特別な日（給料日、ボーナス時期）のフラグ
data['is_payday'] = data['day'].apply(lambda x: 1 if x in [25, 26, 27] else 0)  # 給料日付近
data['is_bonus_month'] = data['month'].apply(lambda x: 1 if x in [6, 12] else 0)  # ボーナス月

# 天気の影響（ランダムだが現実的な分布）
weather_types = ['晴れ', '曇り', '雨', '雪']  # 天気の種類
weather_weights = [0.5, 0.3, 0.15, 0.05]    # 各天気の出現確率
data['weather'] = np.random.choice(weather_types, n_samples, p=weather_weights)

# 天気を数値化（売り上げへの影響度）
weather_impact = {'晴れ': 1.0, '曇り': 0.9, '雨': 0.7, '雪': 0.5}
data['weather_score'] = data['weather'].map(weather_impact)

# イベント情報（特別な日）
special_events = np.random.choice([0, 1], n_samples, p=[0.9, 0.1])  # 10%の確率でイベント
data['has_event'] = special_events

# キャスト人数（営業に影響）
base_cast = 8  # 基本キャスト数
data['cast_count'] = np.random.poisson(base_cast, n_samples)  # ポアソン分布で変動

# 目標売り上げを計算（現実的な要因を組み合わせ）
base_sales = 50000  # 基本売り上げ（円）

# 曜日効果（金土が高い）
weekday_multiplier = [0.7, 0.7, 0.8, 0.9, 1.3, 1.5, 1.2]  # 月～日の係数
data['weekday_effect'] = data['weekday'].apply(lambda x: weekday_multiplier[x])

# 月次効果（12月、3月が高い傾向）
monthly_multiplier = [0.9, 0.8, 1.2, 1.0, 0.9, 1.1, 1.0, 0.9, 0.9, 1.0, 1.0, 1.3]
data['monthly_effect'] = data['month'].apply(lambda x: monthly_multiplier[x-1])

# 売り上げ計算（複数要因の組み合わせ）
data['sales'] = (
    base_sales *                                    # 基本売り上げ
    data['weekday_effect'] *                        # 曜日効果
    data['monthly_effect'] *                        # 月次効果  
    data['weather_score'] *                         # 天気効果
    (1 + data['is_payday'] * 0.2) *                # 給料日効果（+20%）
    (1 + data['is_bonus_month'] * 0.3) *           # ボーナス月効果（+30%）
    (1 + data['has_event'] * 0.4) *                # イベント効果（+40%）
    (data['cast_count'] / base_cast) *             # キャスト数効果
    np.random.normal(1, 0.1, n_samples)            # ランダムノイズ（±10%）
)

# 売り上げを整数に丸める（現実的にする）
data['sales'] = data['sales'].round().astype(int)

# データの概要を表示
print("🔍 生成されたデータの概要:")
print(f"データ期間: {data['date'].min().strftime('%Y-%m-%d')} ～ {data['date'].max().strftime('%Y-%m-%d')}")
print(f"総レコード数: {len(data):,} 件")
print(f"平均売り上げ: {data['sales'].mean():,.0f} 円")
print(f"売り上げ範囲: {data['sales'].min():,} ～ {data['sales'].max():,} 円")
print()

# 基本統計情報を表示
print("📈 売り上げ統計:")
print(data['sales'].describe())
print()

# 機械学習用の特徴量を準備
feature_columns = [
    'month', 'weekday', 'season', 'is_weekend', 
    'is_payday', 'is_bonus_month', 'weather_score', 
    'has_event', 'cast_count'
]

# 特徴量（X）と目標変数（y）を分離
X = data[feature_columns]  # 説明変数
y = data['sales']          # 目的変数（売り上げ）

print("🎯 使用する特徴量:")
for i, col in enumerate(feature_columns, 1):
    print(f"  {i:2d}. {col}")
print()

# データを訓練用とテスト用に分割（8:2の比率）
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, shuffle=True
)

print(f"📚 データ分割結果:")
print(f"  訓練データ: {len(X_train):,} 件 ({len(X_train)/len(data)*100:.1f}%)")
print(f"  テストデータ: {len(X_test):,} 件 ({len(X_test)/len(data)*100:.1f}%)")
print()

# ランダムフォレスト回帰モデルを作成・訓練
print("🤖 機械学習モデル訓練中...")
model = RandomForestRegressor(
    n_estimators=100,    # 決定木の数
    random_state=42,     # 再現性のため
    max_depth=10,        # 木の最大深度
    min_samples_split=5, # 分割に必要な最小サンプル数
    n_jobs=-1           # 並列処理（全CPU使用）
)

# モデルを訓練データで学習
model.fit(X_train, y_train)
print("✅ モデル訓練完了!")
print()

# テストデータで予測を実行
y_pred = model.predict(X_test)

# モデルの性能を評価
mae = mean_absolute_error(y_test, y_pred)      # 平均絶対誤差
r2 = r2_score(y_test, y_pred)                  # 決定係数

print("📊 モデル性能評価:")
print(f"  平均絶対誤差 (MAE): {mae:,.0f} 円")
print(f"  決定係数 (R²): {r2:.3f}")
print(f"  平均誤差率: {mae/y_test.mean()*100:.1f}%")
print()

# 特徴量の重要度を計算・表示
feature_importance = pd.DataFrame({
    'feature': feature_columns,
    'importance': model.feature_importances_
}).sort_values('importance', ascending=False)

print("🔍 特徴量重要度ランキング:")
for i, (_, row) in enumerate(feature_importance.iterrows(), 1):
    print(f"  {i:2d}. {row['feature']:15s}: {row['importance']:.3f}")
print()

# 可視化用にグラフを作成
fig, axes = plt.subplots(2, 2, figsize=(15, 12))
fig.suptitle('キャバクラ売り上げ分析結果', fontsize=16, fontweight='bold')

# 1. 実際vs予測の散布図
axes[0, 0].scatter(y_test, y_pred, alpha=0.6, color='blue')
axes[0, 0].plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)
axes[0, 0].set_xlabel('実際の売上 (円)')
axes[0, 0].set_ylabel('予測売上 (円)')
axes[0, 0].set_title(f'予測精度 (R² = {r2:.3f})')
axes[0, 0].grid(True, alpha=0.3)

# 2. 曜日別売り上げ傾向
weekday_names = ['月', '火', '水', '木', '金', '土', '日']
weekday_sales = data.groupby('weekday')['sales'].mean()
axes[0, 1].bar(range(7), weekday_sales.values, color='lightblue', edgecolor='navy')
axes[0, 1].set_xlabel('曜日')
axes[0, 1].set_ylabel('平均売上 (円)')
axes[0, 1].set_title('曜日別売上傾向')
axes[0, 1].set_xticks(range(7))
axes[0, 1].set_xticklabels(weekday_names)
axes[0, 1].grid(True, alpha=0.3, axis='y')

# 3. 月別売り上げ推移
monthly_sales = data.groupby('month')['sales'].mean()
axes[1, 0].plot(monthly_sales.index, monthly_sales.values, marker='o', linewidth=2, markersize=6)
axes[1, 0].set_xlabel('月')
axes[1, 0].set_ylabel('平均売上 (円)')
axes[1, 0].set_title('月別売上推移')
axes[1, 0].grid(True, alpha=0.3)
axes[1, 0].set_xticks(range(1, 13))

# 4. 特徴量重要度バープロット
top_features = feature_importance.head(6)  # 上位6つの特徴量
axes[1, 1].barh(range(len(top_features)), top_features['importance'].values, color='lightgreen', edgecolor='darkgreen')
axes[1, 1].set_xlabel('重要度')
axes[1, 1].set_ylabel('特徴量')
axes[1, 1].set_title('特徴量重要度（上位6項目）')
axes[1, 1].set_yticks(range(len(top_features)))
axes[1, 1].set_yticklabels(top_features['feature'].values)
axes[1, 1].grid(True, alpha=0.3, axis='x')

# グラフ間のスペースを調整
plt.tight_layout()
plt.show()

# 将来予測のサンプル（明日の売り上げ予測）
print("🔮 将来予測サンプル（明日の売り上げ）:")

# 明日の日付と特徴量を設定（例として）
tomorrow = datetime.now() + timedelta(days=1)
tomorrow_features = {
    'month': tomorrow.month,
    'weekday': tomorrow.weekday(),
    'season': 0 if tomorrow.month in [12, 1, 2] else 1 if tomorrow.month in [3, 4, 5] else 2 if tomorrow.month in [6, 7, 8] else 3,
    'is_weekend': 1 if tomorrow.weekday() >= 5 else 0,
    'is_payday': 1 if tomorrow.day in [25, 26, 27] else 0,
    'is_bonus_month': 1 if tomorrow.month in [6, 12] else 0,
    'weather_score': 1.0,  # 晴れと仮定
    'has_event': 0,        # イベントなしと仮定
    'cast_count': 8        # 通常のキャスト数と仮定
}

# 予測用データフレームを作成
tomorrow_df = pd.DataFrame([tomorrow_features])

# 売り上げを予測
predicted_sales = model.predict(tomorrow_df)[0]

print(f"  予測対象日: {tomorrow.strftime('%Y年%m月%d日 (%a)')}")
print(f"  予測売上: {predicted_sales:,.0f} 円")
print()

# 条件を変えた場合の予測（What-if分析）
print("💡 What-if分析（条件変更時の予測）:")

# ベース条件をコピー
base_condition = tomorrow_features.copy()

# 1. イベント開催時
event_condition = base_condition.copy()
event_condition['has_event'] = 1
event_sales = model.predict(pd.DataFrame([event_condition]))[0]
event_diff = event_sales - predicted_sales

print(f"  1. イベント開催時: {event_sales:,.0f} 円 ({event_diff:+,.0f} 円)")

# 2. キャスト数増加時
more_cast_condition = base_condition.copy()
more_cast_condition['cast_count'] = 12  # 50%増
more_cast_sales = model.predict(pd.DataFrame([more_cast_condition]))[0]
more_cast_diff = more_cast_sales - predicted_sales

print(f"  2. キャスト数1.5倍時: {more_cast_sales:,.0f} 円 ({more_cast_diff:+,.0f} 円)")

# 3. 雨天時
rain_condition = base_condition.copy()
rain_condition['weather_score'] = 0.7  # 雨の影響
rain_sales = model.predict(pd.DataFrame([rain_condition]))[0]
rain_diff = rain_sales - predicted_sales

print(f"  3. 雨天時: {rain_sales:,.0f} 円 ({rain_diff:+,.0f} 円)")

print()
print("🎉 売り上げ予測システム完了!")
print("=" * 50)

# 予測精度向上のためのアドバイス
print("\n📋 予測精度向上のためのアドバイス:")
print("  1. より多くの実データを収集する")
print("  2. 顧客数、客単価なども特徴量に追加する") 
print("  3. 競合店舗の情報を考慮する")
print("  4. 経済指標（株価、消費者信頼感指数等）を追加する")
print("  5. SNSでのイベント告知効果を数値化する")
print("  6. 定期的にモデルを再学習する")
